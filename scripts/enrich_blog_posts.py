#!/usr/bin/env python3
"""
Enrich course_blog_posts table with descriptions from desc.csv.

This script:
1. Reads the desc.csv file
2. Matches courses by code
3. Creates or updates course_blog_posts entries with website_description
"""

import csv
import sys
from datetime import datetime

def load_descriptions(csv_path: str) -> dict:
    """Load course descriptions from CSV, keyed by course code."""
    descriptions = {}
    try:
        with open(csv_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                code = row.get('code', '').strip().upper()
                description = row.get('description', '').strip()
                if code and description:
                    descriptions[code] = description
        return descriptions
    except Exception as e:
        print(f"Error loading CSV: {e}")
        return {}

def generate_sql_statements(descriptions: dict) -> list:
    """Generate SQL INSERT/UPDATE statements for course_blog_posts."""
    statements = []
    
    # First, get all courses that match the codes
    # We'll generate SQL that uses a subquery to find the course_slug
    
    for code, description in descriptions.items():
        # Escape single quotes in description
        escaped_description = description.replace("'", "''")
        
        # Generate INSERT ... ON CONFLICT DO UPDATE
        # This will create the blog post if it doesn't exist, or update website_description if it does
        sql = f"""
INSERT INTO course_blog_posts (
    course_slug,
    course_code,
    title,
    website_description,
    content,
    published,
    created_at,
    updated_at
)
SELECT 
    c.slug,
    c.code,
    c.title_fr,
    '{escaped_description}',
    'Content will be generated by AI', -- Placeholder content
    false, -- Not published yet
    NOW(),
    NOW()
FROM courses c
WHERE c.code = '{code}' 
  AND c.institution = 'ESG-UQAM'
ON CONFLICT (course_slug) 
DO UPDATE SET
    website_description = EXCLUDED.website_description,
    updated_at = NOW();
"""
        statements.append(sql.strip())
    
    return statements

def main():
    csv_path = 'scripts/desc.csv'
    output_sql = 'scripts/enrich_blog_posts.sql'
    
    print(f"Loading descriptions from {csv_path}...")
    descriptions = load_descriptions(csv_path)
    print(f"Loaded {len(descriptions)} course descriptions")
    
    print(f"Generating SQL statements...")
    statements = generate_sql_statements(descriptions)
    
    print(f"Writing SQL to {output_sql}...")
    with open(output_sql, 'w', encoding='utf-8') as f:
        f.write("-- SQL statements to enrich course_blog_posts with descriptions\n")
        f.write(f"-- Generated: {datetime.now().isoformat()}\n")
        f.write(f"-- Total courses: {len(statements)}\n\n")
        for sql in statements:
            f.write(sql + "\n\n")
    
    print(f"\nGenerated {len(statements)} SQL statements")
    print(f"SQL file: {output_sql}")
    print(f"\nTo execute, run these statements via MCP Supabase execute_sql tool")

if __name__ == '__main__':
    main()

